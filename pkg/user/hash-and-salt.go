package user

import (
	"crypto/rand"
	"crypto/sha1"
	"encoding/base64"
	"fmt"
	"log"

	"golang.org/x/crypto/pbkdf2"

	// "github.com/ztrue/tracerr";
	"math/big"
)

// Original Python function I simplified it a little
/* def gen_nonce(length):
""" Generates a random string of bytes, base64 encoded """
if length < 1:
  return ''
string=base64.b64encode(os.urandom(length),altchars=b'-_')
b64len=4* (length // 3)
if length%3 == 1:
 b64len+=2
elif length%3 == 2:
 b64len+=3
return string[0:b64len].decode() */

func randomBytes(length uint8) []byte {
	if length == 0 {
		log.Fatal("Random array of length 0 is not random!")
	}
	maxx := big.NewInt(256)
	maxx = maxx.Exp(maxx, big.NewInt(int64(length)), nil)
	var randomInt *big.Int
	randomInt, err := rand.Int(rand.Reader, maxx)
	if err != nil {
		msg := fmt.Sprintf(
			"Unable to generate random bytes, error = %v", err)
		log.Fatal(msg)
	}
	return randomInt.Bytes()
}

// GenNonce Generates a random string of bytes, base64 encoded
// Inspired by the discussion in the https://github.com/joestump/python-oauth2/issues/9#
func GenNonce(length uint8) string {
	nonceBytes := randomBytes(length)
	nonceString := string(nonceBytes)
	res := base64.RawURLEncoding.EncodeToString([]byte(nonceString))
	return res
}

const saltBytes = 16

// HashAndSaltPassword generates a dynamic salt, hash and return both
// https://habr.com/ru/post/145648/
func HashAndSaltPassword(password string) (saltBase64, dkBase64 string) {
	salt := randomBytes(saltBytes)
	dk := pbkdf2.Key([]byte(password), salt, 4096, 32, sha1.New)
	saltBase64 = base64.RawURLEncoding.EncodeToString(salt)
	dkBase64 = base64.RawURLEncoding.EncodeToString(dk)
	return
}

/*


// http://security.stackexchange.com/questions/110084/parameters-for-pbkdf2-for-password-hashing
type HashingConfig struct {
hashBytes int // size of the generated hash (to be chosen accordint the the chosen algo)
 saltBytes int // sise of the salt : larger salt means hashed passwords are more resistant to rainbow table
 iterations int // tune so that hashing the password takes about 1 second
 algo string
 encoding string // hex is readable but base64 is shorter
}

var config = HashingConfig{
 hashBytes  : 64,
 saltBytes  : 16,
 iterations : 220000,
 algo       :"sha512",
 encoding   : "base64" };



 /**
  * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
  *
  * Accepts a hash and salt generated by hashPassword, and returns whether the
  * hash matched the password (as a resolved promise).
*/
/* function verifyPassword(password, hashframe) {
    // decode and extract hashing parameters
    hashframe = Buffer.from(hashframe, config.encoding);
    var saltBytes  = hashframe.readUInt32BE(0);
    var hashBytes  = hashframe.length - saltBytes - 8;
    var iterations = hashframe.readUInt32BE(4);
    var salt = hashframe.slice(8, saltBytes + 8);
    var hash = hashframe.slice(8 + saltBytes, saltBytes + hashBytes + 8);
    // verify the salt and hash against the password
    return crypto.pbkdf2Async(password, salt, iterations, hashBytes, config.algo)
        .then(function(verify) {
            if (verify.equals(hash)) return Promise.resolve(true);
            return Promise.resolve(false) ;
        })
}

exports.hashPassword = hashPassword;
exports.verifyPassword = verifyPassword;
*/
// used for testing
/*
 console.time("hash");
 hashPassword("abc")
     .then(function(hash) {
         console.log("hashframe", hash.length, hash);
         console.timeEnd("hash");
         return verifyPassword("abc", hash);
     })
     .then(function()     { console.log("password correct");})
     .catch(function(err) { console.log("err", err);})
*/
