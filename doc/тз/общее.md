# Анархический глоссарий с переводом

## Сущности

### Язык-диалект

tlanguage - язык или диалект. Дерево может выглядеть так:
```
English
 English from «Jargon file»
 English by dr Node Js Hipster
Русский язык
 РЯ от Microsoft
 РЯ в 1С
 РЯ в Информатике-21
 РЯ от Евпатия Коловратова
 РЯ от Октября Ленинова
 РЯ от Архиправослава Гогенцоллернова
 РЯ от Германа Либералова
 РЯ из словаря информатики 1970 года
```
Таким образом, диалекты нужны для того, чтобы учесть переводы из разных источников и субкультур, а также создавать новые, не упираясь в необходимость консенсуса.

### Пользователь 
Пользователь системы и автор текстов (sduser)

### Смысл
Состоит из обозначаемого слова (например, «оператор») и его конкретного смысла, например, «элемент языка программирования, больший, чем выражение. Т.е. условный оператор, но не сложение» - tsense. Смысл существует в контексте языка. Смысл идентифицируется просто неким числовым кодом. Это требует большой аккуратности для
ведения справочника смыслов, и мы не можем убрать это требование аккуратности.

Пример фрагмента tsense
```
1
 Вычислитель
 Устройство для вычисления
 РЯ от Евпатия Коловратова

2
 Компьютер 
 Устройство для вычисления
 РЯ от Германа Либералова

3
 Computer
 A device to do calculations
 English

4 
 Оператор
 Условный оператор, оператор цикла, оператор сложения
 РЯ от Microsoft

5
 Оператор
 Условный оператор, оператор цикла, но не оператор сложения
 РЯ от 1С

6
 Операция
 Сложение, вычитание и пр
 РЯ от 1С

7
 Operator
 Conditional, loop, but not addition and multiplication
 English

8
 Operator
 Conditional, loop, addition and multiplication
 English
```
Как видите, царит, казалось бы, полный хаос, например, operator в английском имеет два близких, но отличающихся смысла. Почему так? Потому что таковы реальные языки, мы должны их отразить, а не пытаться их идеализировать в нашей модели.

В статье смысла допустимы абзацы, списки ul и гиперссылки. Больше ничего. В будущем наверняка понадобится ещё ужесточить и формализовать требования к смыслу.

### Перевод
ttranslation - устанавливает соответствие смыслов. По замыслу, это должны быть смыслы в разных языках. Тут основной вопрос в том, рассматривать ли только равенство смыслов, или также сопоставлять более узкий и более широкий смыслы? Мы пока пытаемся рассматривать только равенство смыслов, поскольку информация о том, что один смысл является подсмыслом другого, мало полезна на практике - мы не можем заменить при переводе широкий смысл на узкий - это приведёт к ошибке в передаче смысла. Замена узкого смысла широким менее критична, но ведёт к потере точности. Не факт, что мы потянем точную передачу смысла вообще, но, во всяком случае, нужно сначала это попробовать, тем более, что это проще. Пример таблицы ttranslation для примера смыслов из вышеследующего пункта про смыслы:
```
1 = 3
2 = 3
1 = 2
4 = 8
5 = 7
// тут напрашивается 4 = 5 + 6, но это усложнение.
```

## Совместная работа

У каждого диалекта есть один-единственный владелец (из таблицы пользователей). При этом, каждый пользователь может создавать свои диалекты, а администратор может дополнительно переназначать владельцев диалекта. 

Только владелец вправе менять диалект, и делает он это только путём приёма предложений. Любой пользователь может нажать на кнопку "редактировать" на любом смысле или переводе, а также "добавить" или "удалить", при этом создаётся его личная копия этого смысла или перевода. Пользователь делает любые изменения в своей личной копии и сохраняет их. Они сохраняются в виде "предложения". При просмотре базы данных пользователь видит то, что он исправил, но может увидеть и оригинал. Т.е. если была статься "вычислитель" - "устройство для вычислений" - "РЯ от Евп.Кол" и человек поменял его на "вычислитель" - "электронное устройство для автоматических вычислений", то он видит в диалекте "РЯ от Евп.Кол" свою редакцию. Но при этом он видит, что его редакция - это только его предложение, и по специальной ссылке может открыть оригинал и конкурирующие предложения от других людей. Предложение имеет свой код в базе смыслов или переводов, что позволяет его однозначно идентифицировать среди всех смыслов и предложений всех пользователей. 

Владелец языка/диалекта может в любой момент принять предложение, при этом все данные из предложения копируются в основную статью диалекта. Предложение при этом удаляется. Для удобства нужно поле «предложить владельцу языка», чтобы автор предложения мог показать, что работа над предложением закончена и его можно вставлять в общий диалект.

Даже если сам владелец языка/диалекта хочет внести изменения, он тоже должен сначала сделать предложение, а затем принять его.

При просмотре предложения доступен режим сравнения, при котором отличия между предложением и оригиналом выделяются цветом (как в git). В целом процесс внесения изменений похож на процесс в git.

В идеале нужно иметь ленту комментариев к предложениям, но это требует больше труда и это вполне можно сделать в рамках форума. 

Не нужно путать предложения и диалекты. Диалект - это целостная версия языка, даже если она принадлежит только одному чудаку. А предложение - это этап совместной работы над конкретным смыслом или переводом. Поэтому, несмотря на схожесть внешнего вида, предложения и диалекты имеют разное предназначение. 

## Дампы базы

Любой пользователь может загрузить дамп базы на любой момент (или, может быть, дампы создаются периодически,чтобы не грузить сервер). Дамп не содержит секретную информацию пользователей (E-mail и хеш-пароля), но из него можно поднять копию сайта без возможности редактирования теми же пользователями. Так гарантируется отсутствие самоуправства, в сочетании с открытостью исходных текстов и наличием документированной процедуры развёртывания системы. 


## Запросы
Как минимум, нужны запросы:

- поиск слова в смыслах и переводах, с настройкой полей, которые нужно искать
- поиск предложений с фильтрацией по слову, пользователю, языку и флагу «предложить владельцу языка».
- поиск диалектов с фильтрацией по предкам, владельцу, названию.

### Технология сохранения запроса

Очевидно, нужно, чтобы можно было сохранить текущий запрос. Предлагается сделать вторую кнопку "сохранить этот запрос". 
Предлагается использовать https://stackoverflow.com/a/547824 - двум формам дать разные имена и обрабатывать сохранение на 
сервере. 
```
<input type="submit" name="button_1" value="Click me">
```

## Нерешённое

### Темы/теги/ключевые слова
В версии google sheets есть "тема". Это достаточно полезно, но и усложняет работу, поскольку нужно тщательно поддерживать справочник тем. Вероятно, нужно добавить в "смысл" поле "ключевые слова", содержащее список тегов/ключевых слов.

### История изменений
По-хорошему нужно, но поначалу можно и без неё. Она более важна для зрелой базы данных, а не на этапе начального заполнения.

### Чем заполнять?
Кроме очевидных предыдущих версий словаря от разных чудаков, где же можно взять смыслы уже в готовом виде? 

Для получения значений нужно брать толковые словари, глоссарии. Например, FIXME можно найти в [файле жаргона](http://www.catb.org/~esr/jargon/html/go01.html)

Правда, и здесь всё не так просто. В разных глоссариях смыслы могут быть очерчены по-разному. Возможно, каждый глоссарий может быть оформлен как отдельный диалект. 

Кодифицировать смыслы можно по принципам RDF или OWL. 


## Разграничение прав

Стандартная схема - пользователь, роль, объект защиты. Права назначаются только ролям. Нюанс состоит в том, что
некоторые роли возникают как побочный эффект возникновения записей в справочниках. Например, такова роль владельца языка.
Все эти данные должны жить на сервере, чтобы было возможно проверять роли в хранимых процедурах.

Вопрос - создавать ли отдельную запись для владельца языка, чтобы было ортогонально, или скомбинировать, чтобы было быстро? 
Из прошлых проектов возьмём и сделаем частично ортогонально. Т.е. объекты защиты, связанные с языком, существуют в единственном
экземпляре, а язык, к которому относится привилегия, указывается в самой привилегии.

### Определение системы прав

Здесь содержатся требования к разграничению прав. Они упрощены, поскольку в реальности у любого человека должен быть заместитель. 

- существует один администратор базы (а если он попал под трамвай?), он может назначать права и редактировать карточки языков
- у языка есть только один владелец. У него есть право на приём и отклонение изменений и переводов (есть дыра, что перевод может принять владелец
обоих сторон перевода), а также право на удаление смыслов и переводов.
- любой незабанненный пользователь может делать версии и отправлять запросы на изменение смыслов и переводов
- забанненный пользователь не может войти в систему

### Реализация системы прав

#### Роли не нужны

Система простая и роли в ней пока что не нужны. Объекты защиты назначаются непосредственно пользователям. 

#### Объекты защиты

Объекты защиты могут ссылаться на сущности в нашей БД, например, на язык. Так, задавая один код объекта защиты, мы
сразу создаём серию объектов защиты, а не один. Известны такие объекты защиты:

- 1 вход в систему (пользователь может быть забанен)
- 2 назначение прав
- 3 редактирование справочника языков
- 4 приём и отклонение запроса на изменения (в конкретном языке)

Таблица объектов защиты не имеет интерфейса, заполняется скриптом. 

#### UI системы прав

Пока что это будет просто набор хранимых процедур, в т.ч. для добавления права и его удаления;
а также отчёт "мои права".

#### БД системы прав

- объекты защиты 'tprivilegekind'
- права, назначенные пользователю (содержит ссылку на язык, к-рая используется не всегда), 'tuserprivilege' 

#### Защита от будущих изменений

С правами получается заморочено, поэтому мы фиксируем только набор функций для проверки прав. Функции будут
примерно такие:

```
ПроверитьПравоНаЯзык(кодПользователя, кодВидаПрава, кодЯзыка)
ПроверитьПраво(кодПользователя, кодВидаПрава)
```

## Prior art

Версия в таблицах google docs, публично доступную копию [можно скачать здесь](https://docs.google.com/spreadsheets/d/1z20rkYFBxX9p3eKwG74fEiuDGcJ1j0ud_spV1JTTe2w/edit?usp=sharing).

Сделано в мире сделано очень много, нужно это использовать. Сразу были отброшены редакторы словарей типа Goldendict - они не подразумевают совместной работы и редактирования отдельных статей. Сейчас я копаюсь в теме обработки естественных языков (ЕЯ) и пытаюсь подобрать тот словарь, который можно было бы взять в качестве источника смыслов. По сути, это должен быть хороший англоязычный глоссарий компьютерных терминов. Далее поток сознания (отчёт о поисковой работе). 

[Семантическая паутина](https://ru.wikipedia.org/wiki/Семантическая_паутина) - вместо слов в этой паутине элементами являются URI. С помощью схемы RDF можно определить набор отношений между элементами (является, владеет и т.п.) и далее на языке RDF описывать семантические отношения между URI. 

Язык RDF - содержит тройки (объект, отношение, объект) из URI. Возможные отношения задаются схемой, их суть не определяется самим языком RDF.

[Язык OWL](https://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/#Translation_of_Axioms_without_Annotations) - язык онтологий для семантического веба. Примеры отношений OWL видны по ссылке в таблице 1:

```
ObjectIntersectionOf( CE1 ... CEn )
ObjectOneOf( a1 ... an )
TransitiveObjectProperty( OPE )
SubAnnotationPropertyOf
```

### Ссылки

Исходные тексты:

- [Цель проекта и исходные тексты](https://github.com/budden/semdict)
- [Устаревшая серверная часть - на node.js](https://bitbucket.org/budden/slovo-ipp)
- [Устаревшая версия клиента на nuxt - отвергнута](https://bitbucket.org/budden/slovo)
- [Устаревший блок авторизации и аутентификации для nuxt - отвергнут](https://github.com/budden/auth-module/commits/dev)
- [Тема на ЛОРе](https://www.linux.org.ru/forum/development/14043753)
